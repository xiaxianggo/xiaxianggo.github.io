<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xia.Blog()</title>
  
  <subtitle>Stay Hungry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-09T15:25:13.799Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xia Xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无锡</title>
    <link href="http://yoursite.com/2018/09/08/%E6%97%A0%E9%94%A1/"/>
    <id>http://yoursite.com/2018/09/08/无锡/</id>
    <published>2018-09-08T09:37:01.000Z</published>
    <updated>2018-09-09T15:25:13.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一座小城，无事可记"><a href="#一座小城，无事可记" class="headerlink" title="一座小城，无事可记 = ="></a>一座小城，无事可记 = =</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一座小城，无事可记&quot;&gt;&lt;a href=&quot;#一座小城，无事可记&quot; class=&quot;headerlink&quot; title=&quot;一座小城，无事可记 = =&quot;&gt;&lt;/a&gt;一座小城，无事可记 = =&lt;/h2&gt;
      
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>JAVA ClassLoader</title>
    <link href="http://yoursite.com/2018/08/08/JAVA-classloader/"/>
    <id>http://yoursite.com/2018/08/08/JAVA-classloader/</id>
    <published>2018-08-08T04:53:41.000Z</published>
    <updated>2018-09-09T15:22:50.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载器的基本概念"><a href="#类加载器的基本概念" class="headerlink" title="类加载器的基本概念"></a>类加载器的基本概念</h2><p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。<br><a id="more"></a></p><h2 id="ClassLoader-介绍"><a href="#ClassLoader-介绍" class="headerlink" title="ClassLoader 介绍"></a>ClassLoader 介绍</h2><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。为了完成加载类的这个职责，ClassLoader提供了一系列的方法</p><h2 id="ClassLoader-中与加载类相关的方法"><a href="#ClassLoader-中与加载类相关的方法" class="headerlink" title="ClassLoader 中与加载类相关的方法"></a>ClassLoader 中与加载类相关的方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr><td>loadClass(String name)</td><td>查找名称为 name的类，返回的结果是 java.lang.Class类的实例.</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr><td>defineClass(String name, byte<a href=""></a> b, int off, int len)</td><td>把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td></tr></tbody></table><h2 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h2><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</li><li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。</li></ul><p> 除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。<br>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。图 1中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/image001.jpg" alt="" title="类加载器的树状结构"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTree &#123; </span><br><span class="line">   public static void main(String[]() args) &#123; </span><br><span class="line">       ClassLoader loader = ClassLoaderTree.class.getClassLoader(); </span><br><span class="line">       while (loader != null) &#123; </span><br><span class="line">           System.out.println(loader.toString()); </span><br><span class="line">           loader = loader.getParent(); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载器的基本概念&quot;&gt;&lt;a href=&quot;#类加载器的基本概念&quot; class=&quot;headerlink&quot; title=&quot;类加载器的基本概念&quot;&gt;&lt;/a&gt;类加载器的基本概念&lt;/h2&gt;&lt;p&gt;顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。&lt;br&gt;
    
    </summary>
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA GC</title>
    <link href="http://yoursite.com/2016/11/22/JAVA-GC/"/>
    <id>http://yoursite.com/2016/11/22/JAVA-GC/</id>
    <published>2016-11-22T13:33:00.000Z</published>
    <updated>2018-09-09T15:24:18.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Understanding-Java-Garbage-Collection"><a href="#Understanding-Java-Garbage-Collection" class="headerlink" title="Understanding Java Garbage Collection"></a>Understanding Java Garbage Collection</h2><p>What are the benefits of knowing how garbage collection (GC) works in Java? Satisfying the intellectual curiosity as a software engineer would be a valid cause, but also, understanding how GC works can help you write much better Java applications.<br><a id="more"></a><br>This is a very personal and subjective opinion of mine, but I believe that a person well versed in GC tends to be a better Java developer. If you are interested in the GC process, that means you have experience in developing applications of certain size. If you have thought carefully about choosing the right GC algorithm, that means you completely understand the features of the application you have developed. Of course, this may not be common standards for a good developer. However, few would object when I say that understanding GC is a requirement for being a great Java developer.<br>This is the first of a series of “Become a Java GC Expert” articles. I will cover the GC introduction this time, and in the next article, I will talk about analyzing GC status and GC tuning examples from NHN.<br>There is a term that you should know before learning about GC. The term is “stop-the-world.” Stop-the-world will occur no matter which GC algorithm you choose. Stop-the-world means that the JVM is stopping the application from running to execute a GC. When stop-the-world occurs, every thread except for the threads needed for the GC will stop their tasks. The interrupted tasks will resume only after the GC task has completed. GC tuning often means reducing this stop-the-world time.</p><h2 id="Generational-Garbage-Collection"><a href="#Generational-Garbage-Collection" class="headerlink" title="Generational Garbage Collection"></a>Generational Garbage Collection</h2><p>Java does not explicitly specify a memory and remove it in the program code. Some people sets the relevant object to null or use System.gc() method to remove the memory explicitly. Setting it to null is not a big deal, but calling System.gc() method will affect the system performance drastically, and must not be carried out. (Thankfully, I have not yet seen any developer in NHN calling this method.)<br>In Java, as the developer does not explicitly remove the memory in the program code, the garbage collector finds the unnecessary (garbage) objects and removes them. This garbage collector was created based on the following two hypotheses. (It is more correct to call them suppositions or preconditions, rather than hypotheses.) </p><ul><li>Most objects soon become unreachable.</li><li>References from old objects to young objects only exist in small numbers.</li></ul><p>These hypotheses are called the weak generational hypothesis. So in order to preserve the strengths of this hypothesis, it is physically divided into two - young generation and old generation - in HotSpot VM.<br>Young generation: Most of the newly created objects are located here. Since most objects soon become unreachable, many objects are created in the young generation, then disappear. When objects disappear from this area, we say a “minor GC” has occurred.<br>Old generation: The objects that did not become unreachable and survived from the young generation are copied here. It is generally larger than the young generation. As it is bigger in size, the GC occurs less frequently than in the young generation. When objects disappear from the old generation, we say a “major GC” (or a “full GC”) has occurred. </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Understanding-Java-Garbage-Collection&quot;&gt;&lt;a href=&quot;#Understanding-Java-Garbage-Collection&quot; class=&quot;headerlink&quot; title=&quot;Understanding Java Garbage Collection&quot;&gt;&lt;/a&gt;Understanding Java Garbage Collection&lt;/h2&gt;&lt;p&gt;What are the benefits of knowing how garbage collection (GC) works in Java? Satisfying the intellectual curiosity as a software engineer would be a valid cause, but also, understanding how GC works can help you write much better Java applications.&lt;br&gt;
    
    </summary>
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2016/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/09/08/设计模式/</id>
    <published>2016-09-08T08:13:45.000Z</published>
    <updated>2018-09-09T15:24:21.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><pre><code>设计模式是开发过程，常用的一些理论方法。比如单例模式、工厂模式等。旨在快速构造出，可复用，便维护，有助于团队协作的高质量代码。设计模式是一套代码设计「经验的总结」。项目中「合理的」运用设计模式可以「巧妙的解决很多问题」。   </code></pre><a id="more"></a>   <p>合理的：要对设计模式的使用场景有一定的认识后才使用，「不要滥用」。如：输出一句“hello world”，非要强行给加上各种模式。<br>经验的总结：抱着「代码虐我千百遍，我待代码如初恋」的心态，最终得出来的「套路」。<br>巧妙的解决了很多问题：被广泛应用的原因。</p><h2 id="三大基本特性：封装，继承，多态"><a href="#三大基本特性：封装，继承，多态" class="headerlink" title="三大基本特性：封装，继承，多态"></a>三大基本特性：封装，继承，多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;设计模式是开发过程，常用的一些理论方法。比如单例模式、工厂模式等。旨在快速构造出，可复用，便维护，有助于团队协作的高质量代码。
设计模式是一套代码设计「经验的总结」。项目中「合理的」运用设计模式可以「巧妙的解决很多问题」。   
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
    
  </entry>
  
</feed>
